

<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

const config = {
  type: Phaser.AUTO, // Which renderer to use
  width: 1280, // Canvas width in pixels
  height: 1280, // Canvas height in pixels
  parent: "game-container", // ID of the DOM element to add the canvas to
  scene: {
    preload: preload,
    create: create,
    update: update
  },
  physics: {
    default: "arcade",
    arcade: {
      gravity: { y: 0 }, // Top down game, so no gravity
      debug: false
    }
  }
};

const game = new Phaser.Game(config);

function preload() {
  // Runs once, loads up assets like images and audio
  this.load.image("tiles", "./assets/tilesets/tuxmon-sample-32px-extruded.png");
  this.load.tilemapTiledJSON("map", "./assets/tilemaps/tuxemon-town.json");
  /*
  this.load.spritesheet('dude', 
            'assets/dude.png',
            { frameWidth: 32, frameHeight: 48 }
        );
        */
  this.load.atlas("atlas", "./assets/atlas/atlas.png", "./assets/atlas/atlas.json");
  this.load.image('banana', 'assets/bananas.png');
  this.load.image('red_apple', 'assets/red_apple.png');

}

let player;
var score_1 = 0;
var scoreText_1;
var change_score_1 = 0

var score_2 = 0;
var scoreText_2;
var change_score_2 = 0


function spawnSpriteAtRandomTile() {
    
    const randomIndex = Phaser.Math.Between(0, spawnable_tiles.length - 1);
    const randomTile = spawnable_tiles[randomIndex];
    
    // Convert tile coordinates to world coordinates
    const worldX = randomTile.x/40 * config.width;
    const worldY = randomTile.y/40 * config.height;

    // Spawn the sprite at the calculated position
    return {
        worldX: worldX,  // Some value for worldX
        worldY: worldY   // Some value for worldY
    };
}

function hitBanana (player, banana)
    {	
      banana.disableBody(true, true);
          
      change_score_1 = score_1;
      score_1 = score_1 - 20;
      scoreText_1.setText('Score'+': ' + score_1);
        

      player.setTint(0x00ff00);

      
        
        if (bananas.countActive(true) === 0)
        {
            bananas.children.iterate(function (child) {
              spawns = spawnSpriteAtRandomTile() 
              console.log(spawns)
              child.enableBody(true, spawns.worldX, spawns.worldY, true, true);

            });
         }

    }

function eatAltarBanana (player, apple)
    {   
      player.clearTint();
      apple.disableBody(true, true);
        
        // Enable the sprite's physics body
	    apple.enableBody(true, 1076, 194, true, true);
	    
	    // Set the sprite's alpha to 0 (make it fully transparent)
	    apple.setAlpha(0);
	    
	    // Use a tween to fade the sprite in
	    this.tweens.add({
	        targets: apple,
	        alpha: 1,  // Target alpha value (fully opaque)
	        duration: 3000,  // Duration in milliseconds
	        ease: 'Linear'  // Transition style
	    });
        
    }    
function collectStar (player, star)
    {   

        star.disableBody(true, true);
        
        score_1 += 10;
        scoreText_1.setText('Score' +': ' + score_1);
            
         if (red_apples.countActive(true) === 0)
        {   
            
            
            red_apples.children.iterate(function (child) {
              spawns = spawnSpriteAtRandomTile() 
              console.log(spawns)
              child.enableBody(true, spawns.worldX, spawns.worldY, true, true);

            });
          }
    }


function getCollision(obj_arr) {
  let obj = obj_arr.find(item => item.name === 'collides');
  let value = obj ? obj.value : false;
  return value;
}

function getSpawnable(obj_arr) {
  
  let obj = obj_arr.find(item => item.name === 'can_spawn');
  let value = obj ? obj.value : false;
  return value;
}

spawnable_tiles = []

function getAvailableTiles(map) {
    let availableTiles = [];
    layerName = 'spawn_layer'
    const layer = map.getLayer(layerName).data;

    for (let y = 0; y < layer.length; y++) {
        for (let x = 0; x < layer[y].length; x++) {
            let tile = layer[y][x];
            
            // Check if the tile meets your criteria
            if (tile.index !== -1) {
                availableTiles.push({ x: x, y: y });
            }
        }
    }

    spawnable_tiles = availableTiles;
}


function create() {
  
  map = this.make.tilemap({ key: "map" });
  // Parameters are the name you gave the tileset in Tiled and then the key of the tileset image in
  // Phaser's cache (i.e. the name you used in preload)
  const tileset = map.addTilesetImage("tuxmon-sample-32px-extruded", "tiles");
  const tileWidth = 32; // Or whatever your tile width is
  const tileHeight = 32; // Or whatever your tile height is
  const scaleFactorX = config.width / (map.width * tileWidth);
  const scaleFactorY = config.height / (map.height * tileHeight);

  // belowLayer = map.createStaticLayer("Below Player", tileset, 0, 0).setScale(scaleFactorX, scaleFactorY);
   //worldLayer = map.createStaticLayer("World", tileset, 0, 0).setScale(scaleFactorX, scaleFactorY);
   //aboveLayer = map.createStaticLayer("Above Player", tileset, 0, 0).setScale(scaleFactorX, scaleFactorY);
   //spawnLayer = map.createStaticLayer("spawn_layer", tileset, 0, 0).setScale(scaleFactorX, scaleFactorY);
  belowLayer = map.createStaticLayer("Below Player", tileset, 0, 0);
  worldLayer = map.createStaticLayer("World", tileset, 0, 0);
  aboveLayer = map.createStaticLayer("Above Player", tileset, 0, 0);
  spawnLayer = map.createStaticLayer("spawn_layer", tileset, 0, 0)
  
  aboveLayer.setDepth(10);
  const spawnPoint = map.findObject("Objects", obj => obj.name === "Spawn Point");
  console.log('spawn point',spawnPoint)
  /*
  players = this.physics.add.group({
            key: 'dude',
            repeat: 0,
            setXY: { x: 400, y: 325 }
        });*/
  
  cursors = this.input.keyboard.createCursorKeys();
  
  player = this.physics.add
    .sprite(spawnPoint.x,spawnPoint.y, "atlas", "misa-front")
    .setSize(30, 40)
    .setOffset(0, 24);
  this.physics.add.collider(player, worldLayer);
  const anims = this.anims;
  anims.create({
    key: "misa-left-walk",
    frames: anims.generateFrameNames("atlas", { prefix: "misa-left-walk.", start: 0, end: 3, zeroPad: 3 }),
    frameRate: 10,
    repeat: -1
  });
  anims.create({
    key: "misa-right-walk",
    frames: anims.generateFrameNames("atlas", { prefix: "misa-right-walk.", start: 0, end: 3, zeroPad: 3 }),
    frameRate: 10,
    repeat: -1
  });
  anims.create({
    key: "misa-front-walk",
    frames: anims.generateFrameNames("atlas", { prefix: "misa-front-walk.", start: 0, end: 3, zeroPad: 3 }),
    frameRate: 10,
    repeat: -1
  });
  anims.create({
    key: "misa-back-walk",
    frames: anims.generateFrameNames("atlas", { prefix: "misa-back-walk.", start: 0, end: 3, zeroPad: 3 }),
    frameRate: 10,
    repeat: -1
  });
  /*
  const camera = this.cameras.main;
  camera.startFollow(player);
  camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
  */

  /*
  this.anims.create({
      key: 'left',
      frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
      frameRate: 10,
      repeat: -1
  });
  
  this.anims.create({
      key: 'turn',
      frames: [ { key: 'dude', frame: 4 } ],
      frameRate: 20
  });

  this.anims.create({
      key: 'right',
      frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
      frameRate: 10,
      repeat: -1
  });
  */
  worldLayer.setCollisionByProperty({ collides: true });
  worldLayer.setCollisionByExclusion([-1], true);

  
  this.physics.add.collider(player, worldLayer);
  //player.body.collideWorldBounds=true;

  

  getAvailableTiles(map)
  console.log(spawnable_tiles)
  red_apples = this.physics.add.group();
  for (let i = 0; i < 2; i++) {
    spwans = spawnSpriteAtRandomTile()
    console.log(spwans)
    red_apples.create(spwans.worldX, spwans.worldY, 'red_apple');
  }
  red_apples.children.iterate(sprite => sprite.setScale(0.15));

  bananas = this.physics.add.group();
  for (let i = 0; i < 2; i++) {
    spwans = spawnSpriteAtRandomTile()
    bananas.create(spwans.worldX, spwans.worldY, 'banana');
  }
  red_apples.children.iterate(sprite => sprite.setScale(0.15));
  bananas.children.iterate(sprite => sprite.setScale(0.15));

  this.physics.add.overlap(player, red_apples, collectStar, null, this);
  this.physics.add.overlap(player, bananas, hitBanana, null, this);

  altar_banana = this.physics.add.sprite(1076, 194, 'banana').setScale(0.25);
  this.physics.add.overlap(player, altar_banana, eatAltarBanana, null, this);
  bananas.children.iterate(sprite => sprite.setScale(0.12));

  scoreText_1 = this.add.text(16, 30, 'Score: 0', { fontSize: '28px', fill: "#000000",backgroundColor: "#ffffff" });
}


function update(time, delta) {
  /*
  // Runs once per frame for the duration of the scene
  players.getChildren()[0].body.setVelocity(0);
  if (cursors.left.isDown)
    {
        //players.getChildren()[0].setVelocityX(-160);
        players.getChildren()[0].anims.play('left', true);
        players.getChildren()[0].body.setVelocityX(-100);
        
    }
    else if (cursors.right.isDown)
    {
        //players.getChildren()[0].setVelocityX(160);
        players.getChildren()[0].anims.play('right', true);
        players.getChildren()[0].body.setVelocityX(100);
        
    }
    else
    {   
        players.getChildren()[0].anims.play('turn');
    }
    if (cursors.up.isDown) {
      players.getChildren()[0].body.setVelocityY(-100);
    } else if (cursors.down.isDown) {
      players.getChildren()[0].body.setVelocityY(100);
    }
    //players.getChildren()[0].body.velocity.normalize().scale(speed);
    

  // 1. Get the world X and Y of the player
  
  let playerWorldX = player.x;
  let playerWorldY = player.y;

  // 2. Convert the world coordinates to tile coordinates
  let playerTileX = worldLayer.worldToTileX(playerWorldX);
  let playerTileY = worldLayer.worldToTileY(playerWorldY);

  // 3. Print the tile coordinates to the console
  console.log(`Player is on tile X: ${playerTileX}, Y: ${playerTileY}`);
  let tile = map.getTileAt(playerTileX, playerTileY, true, "World");  // replace x, y with your tile coordinates
  if (tile && getCollision(tile.layer.properties)) {
      console.log("Tile at x, y has collides property set to true!");
  } else{
    console.log("Tile at x, y has collides property set to false!");

  }
  */

  const speed = 175;
  const prevVelocity = player.body.velocity.clone();

  // Stop any previous movement from the last frame
  player.body.setVelocity(0);

  // Horizontal movement
  if (cursors.left.isDown) {
    player.body.setVelocityX(-speed);
  } else if (cursors.right.isDown) {
    player.body.setVelocityX(speed);
  }

  // Vertical movement
  if (cursors.up.isDown) {
    player.body.setVelocityY(-speed);
  } else if (cursors.down.isDown) {
    player.body.setVelocityY(speed);
  }

  // Normalize and scale the velocity so that player can't move faster along a diagonal
  player.body.velocity.normalize().scale(speed);

  // Update the animation last and give left/right animations precedence over up/down animations
  if (cursors.left.isDown) {
    player.anims.play("misa-left-walk", true);
  } else if (cursors.right.isDown) {
    player.anims.play("misa-right-walk", true);
  } else if (cursors.up.isDown) {
    player.anims.play("misa-back-walk", true);
  } else if (cursors.down.isDown) {
    player.anims.play("misa-front-walk", true);
  } else {
    player.anims.stop();

    // If we were moving, pick and idle frame to use
    if (prevVelocity.x < 0) player.setTexture("atlas", "misa-left");
    else if (prevVelocity.x > 0) player.setTexture("atlas", "misa-right");
    else if (prevVelocity.y < 0) player.setTexture("atlas", "misa-back");
    else if (prevVelocity.y > 0) player.setTexture("atlas", "misa-front");
  }


}

</script>

</body>
</html>